import crypto from 'crypto';
import oxigraph, { Store } from 'oxigraph'; // Import Store as a value (class constructor)
import { Person, Address, Hobby } from '../../src/chained-select/example-types'; // Corrected path
// Import RDF utils from the consolidated file
import {
  objectToQuads,
  generateUpdateSparql,
  fetchAndReconstruct, // Moved import here
  MappingConfiguration // Import type from rdf-utils
} from '../../src/chained-select/rdf-utils'; // Corrected path
import { createOxigraphExecutor } from '../../src/chained-select/oxigraph-executor'; // Corrected path
import mapping from './mapping'; // Path is already correct

// --- Configuration ---
const baseUri = 'http://example.org/data/'; // Base URI for generating resource identifiers

// --- Helper Function ---
async function runRoundTripDemo() {
  console.log('--- Starting RDF Round Trip Demo ---');

  // 1. Create sample data
  const sampleAddress: Address = {
    uri: '', // Will be generated
    street: '123 Main St',
    city: 'Anytown',
    postalCode: '12345',
    country: 'USA',
  };

  const sampleHobby1: Hobby = {
    uri: '', // Will be generated
    name: 'Programming',
    yearsPracticed: 10,
  };

  const sampleHobby2: Hobby = {
    uri: '', // Will be generated
    name: 'Hiking',
    yearsPracticed: 5,
  };

  const samplePerson: Person = {
    uri: '', // Will be generated by objectToQuads
    id: crypto.randomUUID(), // Keep a separate unique ID if needed
    firstName: 'John',
    lastName: 'Doe',
    age: 30,
    currentAddress: sampleAddress,
    hobbies: [sampleHobby1, sampleHobby2],
  };

  console.log('\n1. Original Person Object:');
  console.log(JSON.stringify(samplePerson, null, 2));

  // 2. Convert the Person object to Quads
  // objectToQuads will assign URIs (e.g., urn:uuid:...) if obj.uri is empty
  const personQuads = objectToQuads(samplePerson, 'Person', mapping, baseUri);
  const personUri = samplePerson.uri; // Get the generated/assigned URI

  if (!personUri) {
    console.error("Failed to get URI for the person object after conversion.");
    return;
  }

  console.log(`\n2. Converted to ${personQuads.length} RDF Quads (Subject URI: ${personUri})`);
  // console.log(personQuads); // Uncomment to see quads

  // 3. Set up Oxigraph Store
  // Use the exported Store class directly, as confirmed by user feedback and type definitions
  const store: Store = new Store();
  console.log('\n3. Initialized In-Memory Oxigraph Store');

  // 4. Load Quads into the Store
  try {
    // Use store.add() for each quad - MemoryStore is synchronous here
    // @ts-ignore - Oxigraph's .d.ts seems incorrect for store.add, expecting 'never'
    personQuads.forEach(quad => store.add(quad));
    console.log(`4. Loaded ${personQuads.length} quads into the store.`);
  } catch (error) {
    console.error('Error loading quads into Oxigraph store:', error);
    return;
  }

  // 5. Create the SPARQL Executor
  const executeQuery = createOxigraphExecutor(store);
  console.log('\n5. Created Oxigraph SPARQL Executor');

  // 6. Fetch and Reconstruct the Object Graph
  console.log('\n6. Fetching and Reconstructing object graph from store...');
  try {
    // Fetch starting from the main person's URI
    const reconstructedPersons = await fetchAndReconstruct<Person>(
      [personUri], // Start with the person's URI
      'Person',    // Specify the starting type
      mapping,     // Provide the mapping configuration
      executeQuery // Provide the executor function
      // Optional: maxDepth, subjectVar can be added here if needed
    );

    if (reconstructedPersons.length > 0) {
      console.log('\n7. Reconstructed Person Object:');
      // Use JSON.stringify to handle potential circular references if stitching is deep
      const initialReconstructedPerson = reconstructedPersons[0];
      console.log(JSON.stringify(initialReconstructedPerson, null, 2));

      // --- 8. Test Update Functionality ---
      console.log('\n--- Starting Update Test ---');

      // Create a modified version of the person
      // IMPORTANT: Deep clone the reconstructed object to avoid modifying the original reference
      const updatedPerson: Person = JSON.parse(JSON.stringify(initialReconstructedPerson));
      updatedPerson.age = 31; // Change age
      updatedPerson.hobbies = updatedPerson.hobbies.filter(h => h.name !== 'Hiking'); // Remove Hiking hobby
      // Add a new hobby
      const newHobby: Hobby = {
        uri: '', // Let the system generate a URI for the new hobby
        name: 'Reading',
        yearsPracticed: 20
      };
      updatedPerson.hobbies.push(newHobby);

      console.log('\n8. Modified Person Object for Update:');
      console.log(JSON.stringify(updatedPerson, null, 2));

      // Generate the update SPARQL
      const updateSparql = generateUpdateSparql(
        initialReconstructedPerson, // The state currently in the store
        updatedPerson,              // The desired new state
        'Person',                   // The type name
        mapping,                    // The mapping configuration
        baseUri                     // The base URI
      );

      console.log('\n9. Generated SPARQL Update Query:');
      console.log(updateSparql);

      // Execute the update query
      if (updateSparql) {
        console.log('\n10. Executing SPARQL Update using store.update()...');
        try {
          // Execute the update query using the store's update method
          store.update(updateSparql); // Oxigraph's Store supports update
          console.log('11. SPARQL Update executed successfully.');

          // 12. Fetch again to verify the update
          console.log('\n12. Fetching again after update...');
          const finalReconstructedPersons = await fetchAndReconstruct<Person>(
            [personUri], // Start with the same person's URI
            'Person',
            mapping,
            executeQuery
          );

          if (finalReconstructedPersons.length > 0) {
            console.log('\n13. Final Reconstructed Person Object (After Update):');
            console.log(JSON.stringify(finalReconstructedPersons[0], null, 2));
          } else {
            console.log('\n13. Failed to reconstruct the person object after update.');
          }

        } catch (error) {
           console.error('Error during SPARQL update execution or re-fetch:', error);
        }
      } else {
        console.log('\n10. No update query generated (objects might be identical or error in generation).');
      }


    } else {
      console.log('\n7. Failed to reconstruct the person object.');
    }
  } catch (error) {
    console.error('Error during initial object reconstruction:', error);
  }

  console.log('\n--- End of Demo ---');
}

// Run the asynchronous demo function
runRoundTripDemo().catch(error => {
  console.error("Demo failed:", error);
});
