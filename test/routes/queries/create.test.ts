import Fastify, { FastifyInstance } from 'fastify';
import { EntityManager } from '../../../src/lib/EntityManager';
import { EntityRegister } from '../../../src/lib/entity-register';
import type { StoredQuery, Thing } from '../../../src/types/schema-dts'; // Import relevant types
import { createStoredQuery, CreateStoredQueryInput } from '../../../src/lib/factories'; // Import factory and input type
import { mockEntityManager, mockParser, resetMocks } from '../../test-utils/mocks'; // Import shared mocks
import { buildTestApp } from '../../test-utils/app-builder'; // Import shared app builder
// Note: common-data is not strictly needed for POST tests, but might be useful later

// --- Test Suite for POST /api/queries ---
describe('POST /api/queries - Unit Tests', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    // Build the app once for all tests in this suite
    app = await buildTestApp();
  });

  beforeEach(() => {
    // Reset mocks using the shared utility function
    resetMocks();
  });

  afterAll(async () => {
    // Close the Fastify instance after all tests are done
    await app.close();
  });

  // --- Test cases for POST route ---
  const queryPayload: CreateStoredQueryInput = {
    name: 'Test Query',
    description: 'A test query description',
    query: 'SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 10',
    libraryId: 'urn:test-library:temp'
  };
  // Simulate the factory creating the full object
  const queryFromFactory = createStoredQuery(queryPayload);

  beforeEach(() => {
    // Common mock setup for successful POST
    (mockEntityManager.saveOrUpdate as jest.Mock).mockResolvedValue(undefined);
    // Mock the subsequent get call in the route to return the created query
    (mockEntityManager.get as jest.Mock).mockResolvedValue(queryFromFactory);
  });

  it('should create a query using factory, save it, and return it', async () => {
    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: queryPayload,
    });

    expect(response.statusCode).toBe(201);
    // Check the response body matches the object returned by the factory/mocked get
    expect(response.json()).toEqual(queryFromFactory);
    // Check saveOrUpdate was called with an object containing the payload data + factory additions
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledWith(expect.objectContaining({
        name: queryPayload.name,
        description: queryPayload.description,
        query: queryPayload.query,
        '@type': 'StoredQuery',
        '@id': expect.any(String), // ID is generated by factory
        queryType: 'SELECT', // Derived by factory
        outputVars: ['o', 'p', 's'], // Derived by factory - Adjusted order to match factory output
        parameters: [], // Derived by factory
        createdAt: expect.any(String), // Timestamp is generated
        updatedAt: expect.any(String) // Timestamp is generated
    }));
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    // Check the subsequent get was called with the ID generated by the route/factory
    // We expect *any* string ID here, as we don't know the exact one generated internally by the route handler's factory call.
    expect(mockEntityManager.get).toHaveBeenCalledWith(expect.any(String), expect.any(EntityRegister));
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
  });

  it('should create a query with LIMIT parameter and return it', async () => {
    const limitPayload: CreateStoredQueryInput = {
      name: 'Limit Query',
      query: 'SELECT * WHERE { ?s ?p ?o } LIMIT 00010',
      libraryId: 'urn:test-library:limit'
    };
    // Simulate factory output including the limit parameter
    const limitQueryFromFactory = createStoredQuery(limitPayload);
    limitQueryFromFactory.hasLimitParameter = ['LIMIT 00010']; // Manually add expected field

    // Mock the get call to return this specific query
    (mockEntityManager.get as jest.Mock).mockResolvedValue(limitQueryFromFactory);
    // Mock detectParameters to return the limit param
    mockParser.detectParameters.mockReturnValue({ valuesParameters: [], limitParameters: ['LIMIT 00010'], offsetParameters: [] });


    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: limitPayload,
    });

    expect(response.statusCode).toBe(201);
    expect(response.json()).toEqual(limitQueryFromFactory); // Check full response
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledWith(expect.objectContaining({
      name: limitPayload.name,
      query: limitPayload.query,
      hasLimitParameter: ['LIMIT 00010'], // Verify saved field
      hasOffsetParameter: undefined // Verify offset is not present
    }));
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
  });

  it('should create a query with OFFSET parameter and return it', async () => {
    const offsetPayload: CreateStoredQueryInput = {
      name: 'Offset Query',
      query: 'SELECT * WHERE { ?s ?p ?o } OFFSET 0005',
      libraryId: 'urn:test-library:offset'
    };
    const offsetQueryFromFactory = createStoredQuery(offsetPayload);
    offsetQueryFromFactory.hasOffsetParameter = ['OFFSET 0005']; // Manually add expected field

    (mockEntityManager.get as jest.Mock).mockResolvedValue(offsetQueryFromFactory);
    mockParser.detectParameters.mockReturnValue({ valuesParameters: [], limitParameters: [], offsetParameters: ['OFFSET 0005'] });

    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: offsetPayload,
    });

    expect(response.statusCode).toBe(201);
    expect(response.json()).toEqual(offsetQueryFromFactory);
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledWith(expect.objectContaining({
      name: offsetPayload.name,
      query: offsetPayload.query,
      hasLimitParameter: undefined,
      hasOffsetParameter: ['OFFSET 0005'] // Verify saved field
    }));
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
  });

  it('should create a query with LIMIT and OFFSET parameters and return it', async () => {
    const limitOffsetPayload: CreateStoredQueryInput = {
      name: 'Limit Offset Query',
      query: 'SELECT * WHERE { ?s ?p ?o } LIMIT 00020 OFFSET 00015',
      libraryId: 'urn:test-library:limit-offset'
    };
    const limitOffsetQueryFromFactory = createStoredQuery(limitOffsetPayload);
    limitOffsetQueryFromFactory.hasLimitParameter = ['LIMIT 00020'];
    limitOffsetQueryFromFactory.hasOffsetParameter = ['OFFSET 00015'];

    (mockEntityManager.get as jest.Mock).mockResolvedValue(limitOffsetQueryFromFactory);
    mockParser.detectParameters.mockReturnValue({ valuesParameters: [], limitParameters: ['LIMIT 00020'], offsetParameters: ['OFFSET 00015'] });


    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: limitOffsetPayload,
    });

    expect(response.statusCode).toBe(201);
    expect(response.json()).toEqual(limitOffsetQueryFromFactory);
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledWith(expect.objectContaining({
      name: limitOffsetPayload.name,
      query: limitOffsetPayload.query,
      hasLimitParameter: ['LIMIT 00020'], // Verify saved field
      hasOffsetParameter: ['OFFSET 00015'] // Verify saved field
    }));
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
  });

  it('should return 500 if saveOrUpdate fails', async () => {
    (mockEntityManager.saveOrUpdate as jest.Mock).mockRejectedValue(new Error('DB Save Error'));

    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: queryPayload,
    });

    expect(response.statusCode).toBe(500);
    // Expect the generic error message returned by the route's catch block
    expect(response.json()).toEqual({ error: 'Internal Server Error: Could not create StoredQuery.' });
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).not.toHaveBeenCalled(); // get should not be called
  });

  it('should return 500 if final get fails after creation', async () => {
    (mockEntityManager.saveOrUpdate as jest.Mock).mockResolvedValue(undefined); // Save succeeds
    (mockEntityManager.get as jest.Mock).mockRejectedValue(new Error('DB Get Error After Create')); // Get fails

    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: queryPayload,
    });

    expect(response.statusCode).toBe(500);
     // Expect the generic error message returned by the route's catch block
    expect(response.json()).toEqual({ error: 'Internal Server Error: Could not create StoredQuery.' });
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1); // get was attempted
  });

  it('should return 500 if final get returns undefined after creation', async () => {
    (mockEntityManager.saveOrUpdate as jest.Mock).mockResolvedValue(undefined); // Save succeeds
    (mockEntityManager.get as jest.Mock).mockResolvedValue(undefined); // Get returns undefined

    const response = await app.inject({
      method: 'POST',
      url: '/api/queries',
      payload: queryPayload,
    });

    expect(response.statusCode).toBe(500);
    expect(response.json()).toEqual({ error: 'Failed to verify StoredQuery creation' });
    expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
    expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
  });

  it('should return 500 if final get returns wrong type after creation', async () => {
    const wrongTypeThing: Thing = { '@id': queryFromFactory['@id'], '@type': 'Library', name: 'Wrong Type' };
     (mockEntityManager.saveOrUpdate as jest.Mock).mockResolvedValue(undefined); // Save succeeds
     (mockEntityManager.get as jest.Mock).mockResolvedValue(wrongTypeThing); // Get returns wrong type

     const response = await app.inject({
       method: 'POST',
       url: '/api/queries',
       payload: queryPayload,
     });

     expect(response.statusCode).toBe(500);
     expect(response.json()).toEqual({ error: 'Failed to verify StoredQuery creation' });
     expect(mockEntityManager.saveOrUpdate).toHaveBeenCalledTimes(1);
     expect(mockEntityManager.get).toHaveBeenCalledTimes(1);
   });

  // TODO: Add tests for validation errors (e.g., missing name/query)
});
